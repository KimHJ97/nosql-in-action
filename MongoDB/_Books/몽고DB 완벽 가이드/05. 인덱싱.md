# 인덱싱

## 1. 인덱싱 소개

인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라 하며, 서버가 쿼리 결과를 찾으려면 전체 내용을 살펴봐야 한다.

- explain(): 실행 계획을 확인할 수 있다.
  - executionStats.executionTimeMillis: 쿼리하는 데 걸린 시간
  - executionStats.totalDocsExamined: 쿼리를 실행하면서 살펴본 도큐먼트 개수
  - executionStats.nReturned: 반환받은 결과의 개수

```javascript
// 예제 데이터 생성
for (i = 0; i < 1000000; i++) {
  db.users.insertOne({
    i: i,
    username: "user" + i,
    age: Math.floor(Matn.random() * 120),
    created: new Date(),
  });
}

// 실행 계획 확인
db.users.find({ username: "user101" }).explain("executionStats");
```

### 인덱스 생성

- createIndex: 인덱스를 생성한다.
  - 인덱스 생성이 오래걸리는 경우 다른 셸에서 db.currentOp()을 실행하거나 mongod의 로그를 확인해 인덱스 구축의 진행률을 체크한다.
  - 인덱싱된 필드를 변경하는 쓰기 작업은 더 오래 걸린다. 데이터가 변경될 때마다 도큐먼트뿐 아니라 모든 인덱스를 갱신해야 하기 때문이다. 인덱스를 생성할 대상 필드를 선택하려면, 자주 쓰는 쿼리와 빨리 수행해야 하는 쿼리를 조사해 공통적인 키 셋을 찾아본다.

```javascript
// 인덱스 생성
db.users.createIndex({ username: 1 });

// 성능 확인
db.users.find({ username: "user99999" }).explain("executionStats");
```

### 복합 인덱스 소개

- 상당수의 쿼리 패턴은 두 개 이상의 키를 기반으로 인덱스를 작성해야 한다.
- 인덱스는 모든 값을 정렬된 순서로 보관하므로 인덱스 키로 도큐먼트를 정렬하는 작업이 훨씬 빨라지게 한다.

```javascript
// 복합 인덱스 생성
db.users.createIndex({ age: 1, username: 1 });

// ✅ 동등 조건: 몽고DB는 정확한 나이로 건너뛸 수 있으며 인덱스 탐색은 데이터를 올바른 순서로 반환하므로 결과를 정렬할 필요가 없다.
db.users.find({ age: 21 }).sort({ username: -1 });

// 🔸 범위 쿼리: 검색 조건에 맞는 인덱스를 사용해 조회
// 결과를 반환하기 전에 메모리에서 정렬해야 한다.
// 결과가 32메가바이트 이상이면 정렬을 거부하는 오류를 반환한다.
db.users.find({ age: { $gte: 21, $lte: 30 } }).sort({ username: 1 });
```

### 몽고DB가 인덱스를 선택하는 방법

쿼리가 들어오면 몽고DB는 쿼리 모양을 확인한다. 모양은 검색할 필드와 정렬 여부 등 추가 정보와 관련 있다. 시스템은 이 정보를 기반으로 쿼리를 충족하는 데 사용할 인덱스 후보 집합을 식별한다.

몽고DB는 각 인덱스 후보에 하나씩 쿼리 플랜을 만들고, 각각 다른 인덱스를 사용하는 병렬 스레드에서 쿼리를 실행한다. 어떤 스레드에서 가장 빨리 결과를 반환하는지 확인하기 위함이다.

쿼리 스레드가 레이스에서 이기려면, 모든 쿼리 결과를 가장 먼저 반환하거나 결과에 대한 시범 횟수를 정렬 순서로 가장 먼저 반환해야 한다. 인메모리 정렬을 하면 비용이 많이 들기 떄문에 정렬 순서는 중요한 부분이다.

서버는 쿼리 플랜의 캐시를 유지하는데, 승리한 플랜은 차후 모양이 같은 쿼리에 사용하기 위해 캐시에 저장된다. 시간이 지나 컬렉션과 인덱스가 변경되면 쿼리 플랜이 캐시에서 제거되고, 몽고DB는 다시 가능한 쿼리 플랜을 실험해 해당 컬렉션 및 인덱스 집합에 가장 적합한 플랜을 찾는다. 쿼리 플랜 캐시는 명시적으로 지울 수 있으며, mongod 프로세스를 다시 시작할 떄도 삭제된다.

### 복합 인덱스 사용

- 동등 필터에 대한 키를 맨 앞에 표시해야 한다.
- 정렬에 사용되는 키는 다중값 필드 앞에 표시해야 한다.
- 다중값 필터에 대한 키는 마지막에 표시해야 한다.

```javascript
// 약 백만 개의 렐코드가 포함된 학생 데이터셋을 이용한다고 가정한다.
// 예시 인덱스 생성
db.student.createIndex({ class_id: 1 });
db.student.createIndex({ student_id: 1, class_id: 1 });

// ❌
// student_id가 50만보다 큰 레코드를 요청하므로 광범위한 student_id 값을 지정한다. 이는 컬렉션에 있는 레코드의 약 절반이다.
db.students
  .find({ student_id: { $gt: 500000, class_id: 54 } })
  .sort({ student_id: 1 })
  .explain("executionStats");

// hint 메서드: 사용할 인덱스를 지정할 수 있다.
// 인덱스 필터는 쿼리, 정렬, 프로젝션 사양의 조합인 쿼리 모양을 사용한다.
db.students
  .find({ student_id: { $gt: 500000, class_id: 54 } })
  .sort({ student_id: 1 })
  .hint({ class_id: 1 })
  .explain("executionStats");

// ✅ 더 나은 인덱스 설계
// 일반적으로 동등 필터를 사용할 필드가 다중값 필터를 사용할 필드보다 앞에 오도록 복합 인덱스를 설계해야 한다.
db.students.createIndex({ class_id: 1, student_id: 1 });

// ❌ explain 출력에서 선정된 쿼리 플랜에 "SORT" 단계가 포함되며, 이제 인메모리 정렬을 수행함을 알 수 있다.
// 인덱스를 더 잘 설계하면 인메모리 정렬을 피할 수 있다.
db.students
  .find({ student_id: { $gt: 500000, class_id: 54 } })
  .sort({ final_grade: 1 })
  .explain("executionStats");

// ✅
db.students.createIndex({ class_id: 1, final_grade: 1, student_id: 1 });
```

- `키 방향 선택하기`
  - 지금까지 인덱스 항목은 모두 오름차순으로 정렬했다. 하지만 두 개 이상의 검색 조건으로 정렬할 떄는 인덱스 키 방향이 서로 달라야 한다.
    - {"age": 1, "name": -1}과 {"age": -1, "name": 1}은 동일한 쿼리를 충족한다.
  - 인덱스 방향은 다중 조건에 따라 정렬할 떄만 문제가 된다. {"age": 1}과 {"age": -1} 은 최적화가 된다.
- `커버드 쿼리 사용하기`
  - 인덱스는 항상 적합한 도큐먼트를 찾는 데 사용되고, 실제 도큐먼트를 가져오기 위해 곧바로 포인터를 따라간다.
  - 하지만, 쿼리가 단지 인덱스에 포함된 필드를 찾는 중이라면 도큐먼트를 가져올 필요가 없다. 인덱스가 쿼리가 요구하는 값을 모두 포함하면, 쿼리가 커버드된다고 한다.
  - 쿼리가 확실히 인덱스만 사용하게 하려면 반환받을 키를 지정해야 한다.
  - 커버드 쿼리에 explain을 실행하면 "FETCH" 단계의 하위 단계가 아닌 "IXSCAN" 단계까 있으며, "executionStats"에서는 "totalDocsExamined"의 값이 0이 된다.
- `암시적 인덱스`
  - 인덱스가 N개의 키를 가지면 키들의 앞부분은 공짜 인덱스가 된다.

### $ 연산자의 인덱스 사용법

- `비효율적인 연산자`
  - $ne 쿼리는 인덱스를 사용하긴 하지만 잘 활용하지는 못한다.
  - $ne로 지정된 항목을 제외한 모든 인덱스 항목을 살펴봐야 하므로 기본적으로 전체 인덱스를 살펴봐야 한다.
  - $nin은 항상 테이블 스캔을 수행한다.
- `범위`
  - 복합 인덱스는 몽고DB가 다중 절 쿼리를 더 효율적으로 실행하도록 돕는다.
  - 다중 필드를 설계할 떄는 완전 일치가 사용될 필드를 첫 번째에, 범위가 사용될 필드를 마지막에 놓는다.
    - 이는 쿼리가 첫 번쨰 인덱스 키와 정확히 일치하는 값을 찾은 후 두 번쨰 인덱스 범위 안에서 검색하게 해준다.
- `OR 쿼리`
  - 현재 몽고DB는 쿼리당 하나의 인덱스만 사용할 수 있다.
  - 다만, $or는 두 개의 쿼리를 수행하고 결과를 합치므로 $or 절마다 하나씩 인덱스를 사용할 수 있다.
  - 일반적으로 두 번 쿼리해서 결과를 병합하면 한 번 쿼리할 때보다 훨씬 비효율적이다. 가능하면 $or보다는 $in을 이용한다.

```javascript
db.foo.find({ $or: [{ x: 123 }, { y: 456 }] }).explain();
```

### 객체 및 배열 인덱싱

몽고DB는 도큐먼트 내부에 도달해서 내장 필드와 배열에 인덱스를 생성하도록 허용한다. 내장 객체와 배열 필드는 복합 인덱스에서 최상위 필드와 결합될 수 있으며, 다소 특수한 경우를 제외하면 대부분 일반적인 인덱스 필드와 같은 방식으로 동작한다.

- `내장 도큐먼트 인덱싱하기`
  - 내장 도큐먼트 자체를 인덱싱하면 내장 도큐먼트의 필드를 인덱승 할떄와 매우 다르게 동작한다.
  - 서브 도큐먼트 전체를 인덱싱하면 서브 도큐먼트 전체를 쿼리할 떄만 도움이 된다.

```javascript
// 예시 데이터
{
    "username": : "sid",
    "loc": {
        "ip": "1.2.3.4",
        "city": "Springfield",
        "state": "NY"
    }
}

// loca의 서브필드에 인덱스 생성
db.users.createIndex({"loc.city": 1})
```

- `배열 인덱싱하기`
  - 배열을 인덱싱하면 배열의 각 요소에 인덱스 항목을 생성한다.

```javascript
// 한 게시물에 댓글이 20개라면 도큐먼트는 20개의 인덱스 항목을 가진다.
// 입력, 갱신, 제거 작업시 모든 배열 요소가 갱신되므로 부담이된다.
db.blog.createIndex({ "comments.date": 1 });
```

- `다중키 인덱스가 미치는 영향`
  - 어떤 도큐먼트가 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시된다.
  - 다중키 인덱스가 사용됐다면 explain에서 isMultiKey 필드가 true로 출력된다.

### 인덱스 카디널리티

카디널리티는 컬렉션의 한 필드에 대해 고유값이 얼마나 많은지 나타낸다. gender 같은 필드는 가질 수 있는 값이 두 가지뿐이며, 이는 매우 낮은 카디널리티로 간주된다. username이나 email 같은 필드는 컬렉션의 각 도큐먼트마다 유일한 값을 가지며, 이는 높은 카디널리티이다.

일반적으로 필드의 카디널리티가 높을수록 인덱싱에 도움이 된다. 검색 범위를 훨씬 작은 결과 셋으로 빠르게 좁힐 수 있기 떄문이다.

## 2. explain 출력

explain은 쿼리에 대한 많은 정보를 제공하며, 느린 쿼리를 위한 중요한 진단 도구다.

- nReturned: 반환된 도큐먼트 개수
- totalKeysExamined: 검색한 인덱스 항목 개수
- totalDocsExamined: 검색한 도큐먼트 개수
- nscannedObjects: 스캔한 도큐먼트 개수
- executionTimeMillis: 서버가 요청을 받고 응답을 보낸 시점까지 걸린 시간
- isMultiKey: 다중키 인덱스 사용 여부
- stage: 인덱스를 사용해 쿼리할 수 있었는지 여부. COLSCAN은 인덱스로 쿼리할 수 없어 컬렉션 스캔을 수행
- needYields: 쓰기 요청을 처리하도록 쿼리가 양보한 횟수
- indexBounds: 인덱스가 어떻게 사용됐는지 설명하며 탐색한 인덱스의 범위 제공

## 3. 인덱스 종류

### 고유 인덱스

고유 인덱스는 각 값이 인덱스에 최대 한 번 나타나도록 보장한다.

그 외에도 복합 고유 인덱스를 만들 수도 있다. 이는 개별 키는 같은 값을 가질 수 있지만 인덱스 항목의 모든 키에 걸친 값의 조합은 인덱스에서 최대 한 번만 나타난다.

```javascript
// 동일한 값을 가질 수 없는 인덱스 생성
// 동일한 값을 생성하려고 하면 중복 키 오류 발생
db.users.createIndex(
  {
    firstname: 1,
  },
  {
    unique: true,
    partialFilterExpression: {
      firstname: {
        $exists: true,
      },
    },
  }
);
```

### 부분 인덱스

고유 인덱스는 null을 값으로 취급하므로, 키가 없는 도큐먼트가 여러 개인 고유 인덱스를 만들 수 없다. 하지만 오직 키가 존재할 때만 고유 인덱스가 적용되도록 할 때가 많다. 고유한 필드가 존재하거나 필드가 아예 존재하지 않으면 unique와 partial을 결합할 수 있다.

- 부분 인덱스는 반드시 고유할 필요는 없다.
- 고유하지 않은 부분 인덱스를 만들려면 unique 옵션을 제외시키기만 하면 된다.

```javascript
// 부분 인덱스 만들기
db.users.ensureIndex(
  {
    email: 1,
  },
  {
    unique: true,
    partialFilterExpression: {
      email: {
        $exists: true,
      },
    },
  }
);
```

## 4. 인덱스 관리

데이터베이스의 인덱스 정보는 모두 system.indexes 컬렉션에 저장된다. 이는 예약된 컬렉션이므로 안에 있는 도큐먼트를 수정하거나 제거할 수 없으며, createIndex, createIndexes, dropIndexes와 같은 명령으로만 조작할 수 있다.

- 인덱스 식별
  - 컬렉션 내 각 인덱스는 고유하게 식별하는 이름이 있다.
  - 인덱스의 키가 키명X이고, 인덱스의 방향이 방향X일 때, 인덱스명은 기본적으로 키명1*방향1*키명2*방향2*키명N\_방향N 이다.
  - 인덱스 키가 두 개 이상이면 인덱스명이 길어질 수 있으므로 createIndex의 옵션으로 원하는 이름을 지정할 수 있다.
- 인덱스 변경
  - 새로운 인덱스를 구축하려면 시간이 오래 걸리고 리소스가 많이 필ㅇ료하다.
  - 몽고DB 4.2+ 부터는 인덱스를 빠르게 구축하기 위해, 인덱스 구축 중에 DB의 모든 읽기와 쓰기를 중단한다.
  - 데이터베이스가 읽기와 쓰기에 어느 정도 응답하게 하려면 인덱스를 구축할 떄 background 옵션을 사용한다. 이는 인덱스 구축이 종종 다른 작업에 양보하도록 강제하지만 여전히 애플리케이션에 큰 영향을 준다.

```javascript
// 특정 컬렉션의 모든 인덱스 정보 확인
db.users.getIndexes();

// 인덱스명 직접 지정
db.users.createIndex(
  {
    // fieldName: sort
  },
  {
    name: "indexName",
  }
);
```
