# 애플리케이션 설계

## 1. 스키마 설계 고려 사항

 - `제약 사항`
    - 도큐먼트의 최대 크기는 16메가바이트이며, 디스크에서 전체 도큐먼트를 읽고 쓴다.
    - 갱신은 전체 도큐먼트를 다시 쓰며, 원자성 갱신은 도큐먼트 단위로 실행된다.
 - `쿼리 및 쓰기의 접근 패턴`
    - 워크로드는 애플리케이션의 읽기와 쓰기를 모두 포함한다. 쿼리가 실행되는 시기와 빈도를 알면 가장 일반적인 쿼리를 식별할 수 있다.
    - 쿼리를 식별한 후에는 쿼리 수를 최소화하고, 함께 쿼리되는 데이터가 동일한 도큐먼트에 저장되도록 설계를 확인해야 한다.
    - 동적(읽기/쓰기) 데이터와 정적(대부분 읽기) 데이터를 분리할 수 있는지도 고려해볼 만하다.
 - `관계 유형`
    - 요구 사항 측면과 도큐먼트 간 관계 측면에서 어떤 데이터가 관련돼 있는지 고려해야 한다. 이후 데이터나 도큐먼트를 내장하거나 참조할 방법을 결정한다.
    - 관계가 변경될 때 갱신되는 도큐먼트 개수를 알아야 한다.
    - 또한 데이터가 쿼리하기 쉬운 구조인지도 고려한다.
 - `카디널리티`
    - 현재 관계가 일대일, 일대다, 다대다, 일대수백만인지 등을 고려한다.
    - 몽고DB 스키마에서 모델링에 최선의 형식을 사용하도록 관계의 카디널리티를 설정하는 것이 매우 중요하다.

### 스키마 설계 패턴

 - `다형성 패턴`
    - 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조를 가질 때 적합
    - 공통 쿼리를 지원하는 도큐먼트에서 공통 필드를 식별하는 것이 포함된다.
    - 도큐먼트나 서브도큐먼트의 특정 필드를 추적하면, 이러한 차이점을 관리하기 위해 애플리케이션에서 코딩할 수 있는 데이터와 다른 코드 경로 도는 클래스/서브클래스 간의 차이점을 식별하는 데 도움이 된다.
 - `속성 패턴`
    - 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우, 정렬하려는 필드가 도큐먼트의 서브셋에만 존재하는 경우 또는 두 조건이 모두 해당하는 경우에 적합
    - 데이터를 키/값 쌍의 배열로 재구성하고 배열 요소에 인덱스를 만드는 작업이 포함된다.
 - `버킷 패턴`
    - 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합하다.
    - 몽고DB에서 이 데이터를 특정 시간 범위의 데이터를 각각 보유하는 도큐먼트 셋으로 버킷화하면 시간/데이터 포인트의 포인트당 도큐먼트를 만들 때보다 훨씬 효율적이다.
 - `이상치 패턴`
    - 도큐먼트의 쿼리가 드물게 애플리케이션의 정상적인 패턴을 벗어날 때 사용한다.
    - 플래그를 사용해 도큐먼트가 이상점임을 나타내며 추가 오버플로를 하나 이상의 도큐먼트에 저장한다.
    - 플래그는 애플리케이션 코드에서 오버플로 도큐먼트를 검색하기 위한 추가 쿼리를 만드는 데 사용된다.
 - `계산된 패턴`
    - 데이터를 자주 계산해야 할 대나 데이터 접근 패턴이 읽기 집약적일 때 사용한다.
    - 주요 도큐먼트가 주기적으로 갱신되는 백그라운드에서 계산을 수행하도록 권장한다.
    - 개별 쿼리에 대해 필드나 도큐먼트를 지속적으로 생성하지 않고도 계산된 필드 및 도큐먼트의 유효한 근사치를 제공한다.
 - `서브셋 패턴`
    - 장비의 램 용량을 초과하는 작업 셋이 있을 때 사용한다.
    - 사용하지 않는 정보를 많이 포함하는 대용량 도큐먼트 떄문에 발생할 수 있다.
    - 서브셋 패턴은 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별 컬렉션으로 분할하도록 한다.
 - `확장된 참조 패턴`
    - 고유한 컬렉션이 있는 여러 논리 엔티티 또는  사물이 있고, 특정 기능을 위해 엔티티들을 모을 때 사용한다.
    - 확장된 참조 패턴은 데이터를 중복시키는 대신 정보를 조합하는 데 필요한 쿼리 수를 줄인다.
 - `근사 패턴`
    - 리소스가 많이 드는 계산이 필요하지만 높은 정확도가 반드시 필요하지 않은 상황에 유용하다.
    - 이미지나 게시글의 추천 수 카운터 또는 페이지 조회 수 카운터를 예로 들수 있다.
    - 근사 패턴을 적용해 추천이나 조회 수가 1회가 아니라 100회가 될 떄마다 카운터를 갱신하면 쓰기 횟수를 크게 줄일 수 있다.
 - `트리 패턴`
    - 쿼리가 많고 구조적으로 주로 계층적인 데이터가 있을 때 적용한다.
    - 전체 계층구조 필드는 배열에 보관돼 해당 값에 다중키 인덱스를 사용하는 기능을 제공한다.
 - `사전 할당 패턴`
    - 주로 MMAP 스토리지 엔진과 함께 사용됐지만 여전히 사용된다.
    - 이 패턴은 빈 구조를 사전 할당한다. 예를 들어 예약 정보를 매일 관리하는 시스템에서, 예약 가능 여부와 현재 예약 상태를 추적하는 데 적용된다.
 - `도큐먼트 버전 관리 패턴`
    - 도큐먼트의 이전 버전을 유지하는 메커니즘을 제공한다.
    - 메인 컬렉션의 도큐먼트 버전을 추적하려면 각 도큐먼트에 부가 필드를 추가해야 하며 도큐먼트의 모든 수정 사항을 포함하는 추가 컬렉션이 필요하다.

## 2. 정규화 vs 비정규화

데이터를 얼마나 정규화할지는 늘 중요한 문제다. 정규화는 컬렉션 간의 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업이다.

비정규화는 모든 데이터를 하나의 도큐먼트에 내장하는 것으로 정규화의 반대다. 여러 도큐먼트가 최종 데이터 사본에 대한 참조를 갖는 대신 데이터의 사본을 가진다. 정보가 변경되면 여러 도큐먼트가 갱신돼야 하지만, 하나의 쿼리로 관련된 모든 데이터를 가져올 수 있음을 뜻한다.

### 데이터 표현 예제

학생과 학생이 수강 중인 과목에 대한 정보를 저장한다고 가정한다. students 컬렉션과 classes 컬렉션으로 표현할 수 있다. studentClasses는 학생과 학생이 수강 중인 과목에 대한 참조를 포함한다.

```javascript
db.studentClasses.findOne({"studentId": id})
{
    "_id": ObjectId(".."),
    "studentId": ObjectId(".."),
    "classes": [
        ObjectId(".."),
        ObjectId(".."),
        ObjectId(".."),
        ObjectId("..")
    ]
}
```

 - 학생이 수강하는 과목 찾기
    - students 컬렉션에서 학생을 쿼리하고, studentClasses 컬렉션에서 과목 "_id"를 쿼리하고, classes 컬렉션에서 과목 정보를 쿼리한다.
    - 과목과 학생이 자주 바뀌거나 데이터를 빠르게 조회해야 할 때가 아니면, 몽고DB에서 일반적으로 데이터를 구조화하는 방법이 아니다.
    - 학생 도큐먼트에 과목에 대한 참조를 내장함으로써 역참조하는 쿼리 중 하나를 제거할 수 있다.
```javascript
{
    "_id": ObjectId(".."),
    "name": "John Doe",
    "classes": [
        ObjectId(".."),
        ObjectId(".."),
        ObjectId(".."),
        ObjectId("..")
    ]
}
```

 - classes 필드는 John Doe가 수강하는 과목의 "_id" 배열을 보관한다. 해당 과목에 대한 정보를 조회하려면 classes 컬렉션에 "_id"로 쿼리한다.
 - 읽기르르 좀 더 최적화하려면 데이터를 완전히 비정규화하고 각 과목을 "classes" 필드에 내장 도큐먼트로 저장해 하나의 쿼리로 모든 정보를 가져오게 할 수 있다.
```javascript
{
    "_id": ObjectId(".."),
    "name": "John Doe",
    "classes": [
        {
            "class": "Trigonometry",
            "credits": 3,
            "room": "204"
        },
        {
            /* 클래스2 */
        },
        {
            /* 클래스3 */
        },
        {
            /* 클래스4 */
        }
    ]
}
```

 - 쿼리를 하나만 사용해 정보를 얻는 장점이 있지만, 더 많은 공간을 차지하고 동기화하기가 더 어렵다. 예를 들어, 물리학이 3학점이 아니라 4학점이라면 물리학을 수강하는 모든 도큐먼트를 갱신해야 한다.
 - 마지막으로 내장과 참조가 혼합된 확장 참조 패턴을 사용한다. 자주 사용하는 정보로 서브도큐먼트의 배열을 생성하고, 추가적인 정보를 실제 도큐먼트를 참조하는 방식이다.
```javascript
{
    "_id": ObjectId(".."),
    "name": "John Doe",
    "classes": [
        {
            "_id": ObjectId(".."),
            "class": "Trigonometry"
        },
        {
            "_id": ObjectId(".."),
            "class": "Physics"
        },
        {
            /* 클래스3 */
        },
        {
            /* 클래스4 */
        }
    ]
}
```

### 친구, 팔로워 그리고 불편한 관계

많은 애플리케이션에서는 사람, 내용, 팔로워, 친구 등을 연결한다. 이렇게 긴밀하게 연결된 정보를 내장할지 혹은 참조할지 적절히 결정하는 방법은 파악하기 까다로울 수 있다.

```javascript
// 게시자를 구독자의 도큐먼트의 넣는 방법 (구독 구현)
{
    "_id": ObjectId(".."),
    "username": "batman",
    "email": "batman@waynetech.com",
    "following": [
        ObjectId(".."),
        ObjectId("..")
    ]
}
```

 - 알림을 보내야 할 모든 사용자를 바로 알 수 있지만, 팔로우하는 사람을 모두 찾으려면 users 컬렉션 전체를 쿼리해야 한다.
 - following 혹은 followers 필드는 반환될 필요가 없을 떄가 많다. 따라서 좀 더 정규화하고 구독을 다른 컬렉션에 저장함으로써 단점을 완화한다.
 - 사용자 도큐먼트를 간단한 형태로 유지하고, 팔로워 정보를 얻으려면 추가 쿼리가 필요하다.
```javascript
{
    "_id": ObjectId(".."), // 팔로우 대상의 "_id"
    "followers": [
        ObjectId(".."),
        ObjectId("..")
    ]
}
```

 - 유명인 사용자로 인한 영향 대첳하기
    - 어떤 전략을 사용하든 내장이 작동하는 서브도큐먼트와 참조의 수는 제한된다.
    - 유명인 사용자의 팔로워를 저장하는 도큐먼트는 넘칠 수 있다.
    - 이는 이상치 패턴을 사용하고 필요하다면 연속 도큐먼트를 사용해 해결할 수 있다.
```javascript
db.users.find({"username": "wil"})
{
    "_id": ObjectId(".."),
    "username": "wil",
    "email": "wil@teest.com",
    "tbc": [
        ObjectId(".."),
        ObjectId("..")
    ],
    "followers": [
        ObjectId(".."),
        ObjectId(".."),
        ObjectId("..")
    ]
}
```

## 3. 일관성 관리

몽고DB는 읽을 데이터의 일관성 격리 속성을 제어하는 readConcern 옵션을 제공한다. writeConcern과 결합하면 애플리케이션에 대한 일관성과 가용성 보장을 제어할 수 있다.
 - local, available, majority, linearizable, snapshot 5개의 수준이 있다.
 - 읽기 부실을 방지하려면 majority를 사용한다. majority는 대부분의 복제 셋 멤버에서 확인된 내구성 있는 데이터만 반환하며 롤백되지 않는다.

