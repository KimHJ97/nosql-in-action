# 복제 셋 설정

## 1. 복제 소개

독립 실행형 서버로 단일 mongod 서버를 구성하는 것은 쉬운 방법이지만 실제 서비스를 운영하는 데 사용하면 매우 위험하다. 단일 장애 지점(SPOF)이 될 수 있고 디스크나 네트워크 문제가 데이터 손상이나 접근 불가 문제를 야기할 수 있다.

복제는 데이터의 동일한 복사본을 여러 서버상에서 보관하는 방법이며 실제 서비스를 배포할 때 권장된다. 한 대 또는 그 이상의 서버에 이상이 발생하더라도, 복제는 애플리케이션이 정상적으로 동작하게 하고 데이터를 안전하게 보존한다.

 - 복제 셋은 클라이언트 요청을 처리하는 프라이머리 서버 한 대와, 프라이머리 데이터의 복사본을 갖는 세컨더리 서버 여러 대로 이루어진다.
 - 프라이머리 서버에 장애가 발생하면 세컨더리 서버는 자신들 중에서 새로운 프라이머리 서버를 산출할 수 있다.

## 2. 복제 셋 설정 - 준비

테스트 복제 셋을 시작하기에 앞서 각 노드에 대해 별도의 데이터 디렉토리를 생성한다.

```bash
# 디렉토리 생성
mkdir -p ~/data/rs{1,2,3}

# mongod 프로세스 실행
mongod --replSet mdbDefGuide --dbpath /data/rs1 --port 27017 --oplogSize 200
mongod --replSet mdbDefGuide --dbpath /data/rs2 --port 27018 --oplogSize 200
mongod --replSet mdbDefGuide --dbpath /data/rs3 --port 27019 --oplogSize 200
```

## 2-1. 네트워크 고려 사항

복제 셋의 모든 멤버는 같은 셋 내 다른 멤버와 연결할 수 있어야 한다. 몽고DB 3.6+ 부터는 mongod는 기본적으로 로컬호스트(127.0.0.1)에만 바인딩된다. 복제 셋의 각 멤버가 다른 멤버와 통신하려면 다른 멤버가 연결할 수 있는 IP 주소에도 바인딩해야 한다. 인스턴스를 각기 다른 서버의 멤버와 함께 복제 셋의 멤버로 실행하려면, 명령행 매개변수 --bind_ip를 지정하거나 인스턴스 구성 파일에 있는 bind_ip를 사용한다.

```bash
mongod --bind_ip localhost,192.51.100.1 --replSet mdbDefGuid \
    --dbpath ~/data/rs1 --port 27017 --smallfiles --oplogSize 200
```

## 2-2. 보안 고려 사항

localhost 이외의 IP 주소에 바인딩하기 전 복제 셋을 구성할 대, 권한 제어를 활성화하고 인증 메커니즘을 지정해야 한다. 또한 디스크의 데이터를 암호화하고, 복제 셋 멤버 간 통신 및 셋과 클라이언트 간 통신을 암호화하면  좋다.

## 3. 복제 셋 설정

현재 실행한 mongod들은 서로를 알지 못한다. 새로운 터미널에서 실행 중인 mongod 인스턴스 중 하나에 접속하여 레플리카 셋을 구성한다.

 - rs는 복제 보조자 함수를 포함하는 전역 변수다.

```javascript
// A 서버 접속
mongo --port 27017

// 복제 셋 초기화
rsconf = {
    _id: "mdbDefGuide", // 복제 셋 이름
    members: [ 
        {_id: 0, host: "localhost:27017"},  // Primary
        {_id: 1, host: "localhost:27018"},  // Secondary
        {_id: 2, host: "localhost:27019"}   // Secondary
    ] 
}
rs.initiate(rsconf) // db.adminCommand({"replSetInitiate": config})
rs.status()
```

## 4. 복제 관찰

```javascript
mongo --port 27017

use test
for (i=0; i<1000; i++) {
    db.coll.insert({count: i})
}

// 마스터 Mongd 확인
db.isMaster()

// 27019 포트 접속
secondaryConn = new Mongo("localhost:27019")
secondaryDB = secondaryConn.getDB("test")

// ❌ 기본적으로 세컨더리는 실효 데이터를 읽지 않도록 읽기 요청 거부
secondaryDB.coll.find()

// ✔ 현재 커넥션에 세컨더리 읽기 허용
secondaryConn.setSlaveOk()
secondaryDB.coll.find()

// ❌ 세컨더리는 클라이언트가 아닌 복제를 통해 가져오는 쓰기만 수행한다.
// WriteError 발생
secondaryDB.coll.insert({"count" : 1001})

// Mongod 종료
db.adminCommand({"shutdown" : 1})

// 마스터 확인(27018로 변경됨)
secondaryDB.isMaster()
```

## 5. 복제 셋 구성 변경

복제 셋 구성에 대한 멤버 추가, 삭제, 변경이 가능하다.

```javascript
// 멤버 추가
rs.add("localhost:27020")

// 멤버 제거
rs.remove("localhost:27017")

// 구성 확인
rs.config()

// 구성 변수로 변경
var config = rs.config()
config.members[0].host = "localhost:27017"
rs.reconfig(config)
```

## 6. 복제 셋 설계 방법

프라이머리를 선출하려면 멤버의 과반수 이상이 필요하고, 프라이머리는 과반수 이상이어야만 프라이머리 자격을 유지할 수 있다. 또한 쓰기는 과반수 이상에 복제되면 안전해진다.

 - 몽고DB는 오직 단일 프라이머리만 지원한다.

### 어떻게 선출하는가

복제 셋 멤버는 2초마다 서로 하트비트를 보낸다. 10초 이내에 멤버가 하트비트가 반환하지 않으면, 다른 멤버가 그 불량 멤버를 '접근할 수 없음'으로 표시한다. 선출 알고리즘은 우선순위가 가장 높은 세컨더리가 선출을 호출하도록 '최선의 노력'을 한다.

 - 어떤 멤버가 프라이머리로 선출되려면 복제 데이터가 최신이어야 한다.

## 7. 멤버 구성 옵션

특정 멤버가 우선적으로 프라이머리가 되게 하거나, 클라이언트에 보이지 않게 해 읽기 요청이 라우팅되지 않도록 할 수 있다. 이를 비롯한 다양한 구성 옵션은 복제 셋 구성의 멤버 서브도큐먼트에 명시할 수 있다.

### 우선순위

특정 멤버가 프라이머리에 대한 우선순위 값을 지정할 수 있다.

 - 0 ~ 100 사이의 값으로 지정한다.
 - 기본값은 1이다.
 - 0으로 지정하면 절대 프라이머리가 될 수 없다. (수동적 멤버)
```javascript
// server-4가 다른 복제 셋 멤버와 같은 최신 데이터로 동기화되면
// 기존 프라이머리는 자격을 내려놓고 server-4 프라이머리로 선출된다.
rs.add({"host" : "server-4:27017", "priority" : 1.5})
```

### 숨겨진 멤버

클라이언트는 숨겨진 멤버에 요청을 라우팅하지 않으며, 숨겨진 멤버는 복제 소스로서 ㅇ바람직하지 않다.

```javascript
// 숨기는 경우 rs.isMaster()에 노출되지 않는다.
// rs.status(), rs.config() 에서는 노출된다.
var config = rs.config()
config.members[2].hidden = true
config.members[2].priority = 0
rs.reconfig(config)
```

### 아비터 선출

소규모 배포에서는 데이터 복사본을 세 개나 보관하기가 꺼려진다. 복사본은 두 개면 충분하고, 세 번쨰 복사본은 관리, 운영, 비용을 고려하면 별 가치가 없다고 생각할 수 있다.

이러한 배포에 대해 몽고DB는 프라이머리 선출에 참여하는 용도로만 쓰이는 아비터라는 특수한 멤버를 지원한다. 아비터는 데이터를 가지지 않으며 클라이언트에 의해 사용되지 않는다. 오로지 멤버 복제 셋에서 과반수를 구성하는 데 사용된다. 일반적으로는 아비터가 없는 배포가 바람직하다.

 - 아비터는 mongod 서버 작동과 아무런 연관이 없다.
 - 아비터는 일반적으로 몽고DB에 사용하는 서버보다 사양이 낮은 서버에서 경량화 프로세스로 실행할 수 있다.
 - 아비터를 한 번 구성하고 나면 프라이머리나 세컨더리로 변경할 수 없다.
```javascript
rs.addArb("server-5:27017")
rs.add({"_id": 4, "host": "server-5:27017", "arbiterOnly": true})
```

 - `아비터 사용시 주의점`
    - __아비터는 최대 하나까지만 사용하라__
        - 노드의 개수가 홀수이면 아비터는 필요하지 않다. 만약의 경우를 대비해서 여분의 아비터를 추가해야 한다고 오해한다. 하지만 아비터를 추가한다고 선출 속도가 빨라지지 않으며, 추가적인 데이터 안전성을 제공하지도 않는다.
        - 아비터를 추가해서 노드 개수가 짝수가 되면 아비터는 동점 상황을 막는게 아니라 오히려 야기할 수 있다.
    - __아비터 사용의 단점__
        - 작은 규모의 복제 셋에서 데이터 노드 대신 아비터를 사용하면 운영 업무가 더 어려워질 수 있다.

### 인덱스 구축

때때로 세컨더리는 프라이머리에 존재하는 것과 동일한 인덱스를 갖지 않아도 되며, 인덱스가 없어도 된다. 세컨더리를 데이터 백업이나 오프라인 배치 작업에만 사용한다면 "buildIndexes" 옵션을 false로 멤버 구성에 명시하면 된다. 이 옵션은 세컨더리가 인덱스를 구축하지 않도록 한다.

 - buildIndexes 옵션은 영구적이다. 일반 멤버로 재구성할 수 없다. 
 - 인덱스 구축 멤버로 변경하려면 복제셋에서 멤버를 제거하고 데이터를 모두 지운 뒤 해당 멤버를 다시 복제 셋에 추가해 처음부터 다시 동기화해야 한다.
 - 옵션 사용시 숨겨진 멤버와 마찬가지로 멤버의 우선순위가 0이어야 한다.
