# 애플리케이션에서 복제 셋 연결

## 1. 클라이언트-복제 셋 연결 동작

몽고DB 3.6+ 부터 서버와 모든 몽고DB 드라이버는 재시도 가능한 쓰기 옵션을 지원한다. 재시도 가능한 쓰기라면 드라이버는 자동으로 최대 한 번 재시도하는 전략을 따른다. 명령 오류는 클라이언트 측 처리를 위해 애플리케이션에 반환된다. 네트워크 오류는 일반적인 상황에서 프라이머리 선출을 수용할 수 있도록 적절한 지연 후 한 번 재시도된다. 재시도 가능한 쓰기를 설정하면 서버는 각 쓰기 연산에 대해 고유한 식별자를 유지하고, 따라서 이미 성공한 명령을 드라이버가 재시도하는 시기를 확인할 수 있다.

## 2. 쓰기 시 복제 대기하기

애플리케이션의 요구 사항에 따라 모든 쓰기가 서버에서 확인되기 전에 대부분의 복제 셋에 복제되도록 요구할 수 있다. 하지만 드물게 복제 셋의 프라이머리가 중단되고 새로 선출된 프라이머리가 마지막 쓰기를 이전 프라이머리에 복제하지 않았을 때는, 이전 프라이머리가 다시 프라이머리가 될 때 해당 쓰기가 롤백된다.

이전 프라이머리가 다시 선출되면 현재 프라이머리에 없는  쓰기를 발견한다. 이를 바로잡기 위해 현재 프라이머리의 연산 순서와 일치하지 않는 쓰기를 실행 취소한다. 이러한 연산은 없어지지 않고, 현재 프라이머리에 수동으로 적용돼야 하는 특수한 롤백 파일에 기록된다. 이것은 관리자가 현재 프라이머리에 롤백 파일을 ㅈ거용할 때까지 본질적으로 사라진다.

과반수에 쓰기를 수행하면 이러한 상황을 방지할 수 있다. 애플리케이션에 쓰기가 성공했다는 확인을 받으면, 새 프라이머리는 선출되려면 쓰기 사본이 있어야 한다.

 - 쓰기 옵션을 majority로 준경우 서버는 쓰기 작업이 복제 셋 멤버 과반수에 복제될 때까지 응답하지 않는다.
 - 지정한 제한 시간 내에 쓰기가 성공하지 못하면 서버는 에러를 반환한다.
 - w에 숫자를 주는 경우 몇 개의 서버에 복제할지 명시할 수 있다.
```javascript
try { 
	db.products.insertOne(
        { 
            "_id": 10, 
            "item": "envelopes", 
            "qty": 100, 
            type: "Self-Sealing" 
        }, 
        { 
            writeConcern: { 
                "w" : "majority", 
                "wtimeout" : 100 
            } 
        } 
    );
} catch (e) {
    print (e);
}
```

## 3. 사용자 정의 복제 보증

### 데이터 센터당 하나의 서버 보장하기

데이터 센터 간의 네트워크 문제는 데이터 센터 내의 문제보다 훨씬 더 일반적이다. 또한 여러 데이터 센터에 걸쳐 서버들이 동등하게 영향을 받기보단 한 개의 데이터 센터 전체가 오프라인이 될 가능성이 더 높다. 따라서 데이터 센터에 특화된 쓰기 로직이 필요할 수도 있다.

```javascript
// 복제 셋 구성에 "tags" 필드 추가
var config = rs.config()
config.members[0].tags = {"dc" : "us-east"}
config.members[1].tags = {"dc" : "us-east"}
config.members[2].tags = {"dc" : "us-east"}
config.members[3].tags = {"dc" : "us-east"}
config.members[4].tags = {"dc" : "us-west"}
config.members[5].tags = {"dc" : "us-west"}
config.members[6].tags = {"dc" : "us-west"}

// 복제 셋 구성에 "getLastErrorMode" 필드를 생성해 규칙을 추가
config.settings = {}
config.settings.getLastErrorModes = [{"eachDC" : {"dc" : 2}}]
rs.reconfig(config)

// 쓰기에 커스텀한 규칙 적용
db.products.insertOne( 
    { "_id": 10, "item": "envelopes", "qty": 100, type: "Self-Sealing" }, 
    { 
        writeConcern: { "w" : "eachDC", wtimeout : 1000 } 
    }
);
```

### 숨겨지지 않은 멤버의 과반수 보장하기

 - host0, host1, host2, host3, host4 총 5 멤버가 있다고 가정
 - host4는 숨겨진 멤버
```javascript
var config = rs.config()
config.members[0].tags = [{"normal" : "A"}]
config.members[1].tags = [{"normal" : "B"}]
config.members[2].tags = [{"normal" : "C"}]
config.members[3].tags = [{"normal" : "D"}]

// 과반수 쓰기 규칙 추가
config.settings.getLastErrorModes = [{"visibleMajority" : {"normal" : 3}}]
rs.reconfig(config)

// 숨겨기지 않은 멤버 중에서 3개가 쓰기를 가질 때 까지 대기
db.products.insertOne({ "_id": 10, "item": "envelopes", "qty": 100, type: "Self-Sealing" }, { writeConcern: { "w" : "visibleMajority", wtimeout : 1000 } } );
```

### 기타 보장 생성하기

 - 키/값 쌍을 할당해서 멤버들을 태깅한다. 키는 분류를 나타낸다. 예를 들어 "data_center"나 "region" 혹은 "serverQuality" 같은 키를 가질 수 있다. 값은 서버가 분류 체계 내에서 어떤 그룹에 속할지 결정한다. 예를 들어 서버에서 키 "data_center"는 "us-east", "uswest", "aust" 등으로 태깅될 수 있다.
 - 생성한 분류 체계에 기반해 규칙을 생성한다. 규칙의 형태는 항상 {"name": {"key": number}}와 같고, 쓰기가 성공하기 전에 number 개의 그룹에서 적어도 하나의 서버는 쓰기를 가져야 한다.

## 4. 세컨더리로 읽기 전송

기본적으로 드라이버는 모든 요청을 프라이머리로 라우팅한다. 드라이버에서 읽기 선호도를 설정해 다른 옵션을 구성할 수도 있다.
 - 세컨더리로 읽기를 보낼 수 있지만, 장단점을 신중히 생각해야 한다.

### 일관성 고려 사항

매우 일관된 읽기가 필요한 애플리케이션은 세컨더리로부터 읽기를 수행하면 안 된다.

 - 세컨더리는 보통 프라이머리의 몇 밀리초 이내에 있어야 하지만, 이는 보장되지 않는다. 때때로 부하, 잘못된 구성, 네트워크 오류 등의 문제로 인해 분, 시간, 심지어 일 단위로 뒤처질 수 있다.
 - 읽기 요청을 항상 프라이머리로 보내려면 읽기 선호도를 primary로 설정한다.

### 부하 고려 사항

많은 사용자가 부하를 분산하려고 읽기를 세컨더리로 전송한다. 예를 들어 서버가 초당 만 개의 쿼리만 처리할 수 있지만 3만 개를 처리하게 하려면, 두 개의 세컨더리를 구성해서 부하를 일부 처리하도록 할 수 있다. 그러나 이러한 확장법은 위험하다. 뜻하지 않게 시스템에 과부하를 유발할 수 있고, 과부하가 발생하면 회복하기 어렵다.

 - 모든 멤버가 부하를 100% 처리할 때 복제 셋의 수용 능력이 낮아지며, 이는 다른 멤버에 더 많은 부하를 줘서 점점 느려지는 악순환이 생긴다.
 - 과부하는 복제가 느려지도록 하며, 남은 세컨더리 역시 뒤처질 수 있다.

### 세컨더리에서 읽기를 하는 이유

몇몇 경우에는 애플리케이션 읽기를 세컨더리로 전송하는 것이 합리적이다. 예를 들어 프라이머리가 다운되더라도 애플리케이션이 지속적으로 읽기 작업을 수행하기를 원할 수 있다.
 - nearest: 요청 일관성보다 낮은 지연율이 중요한 경우(핑 시간 기반 지연율이 가장 낮은 멤버에서 읽기)
 - secondary: 항상 세컨더리에 읽기 요청 (세컨더리가 없으면 에러)
 - secondaryPreferred: 우선 세컨더리에 읽기 요청 (세컨더리가 없으면 프라이머리로 요청)
