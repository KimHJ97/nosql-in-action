# 안전성과 가용성을 위한 클러스터

## 확장성과 분산

### 확장성

확장성(Scalability)은 시스템이나 애플리케이션이 더 많은 작업량이나 부하를 처리하거나 더 많은 리소스를 효과적으로 활용하여 성능을 유지하거나 향상시키는 능력을 말합니다. 간단히 말해, 확장성은 시스템이 더 크거나 더 복잡한 환경에서도 원활하게 동작할 수 있는 능력을 나타냅니다.  
소프트웨어나 서비스의 요구사항 수준이 증가할 때 대응할 수 있는 능력을 말하고, 주로 규모에 대한 확장성을 뜻한다.(데이터 크기, 요청 트래픽 등) 수직 확장(Scale-Up)과 수평 확장(Scale-Out)이 사용된다.  
 - 수직적 확장성 (Vertical Scalability):
    - 수직적 확장성은 단일 서버의 성능을 높이는 방식입니다. 이는 서버의 성능을 향상시키기 위해 CPU, 메모리, 디스크 등의 리소스를 업그레이드하는 것을 의미합니다.
    - 주로 서버의 하드웨어 능력을 증가시켜 단일 서버 내에서 더 많은 작업을 처리하도록 하는 방법입니다.
 - 수평적 확장성 (Horizontal Scalability):
    - 수평적 확장성은 시스템의 성능을 향상시키기 위해 서버의 수를 증가시키는 방식입니다. 이는 여러 서버를 추가하거나 노드를 확장하여 부하 분산을 수행합니다.
    - 주로 분산 시스템이나 클러스터링 환경에서 사용되며, 더 많은 서버를 추가하여 작업량을 분산하여 처리합니다.
    - 처리 요소를 여러개 두어서 작업을 분산하고, 무중단 확장이 가능하다. 이론적으로 무한대로 확장이 가능하다.
        - 부분 장애, 네트워크 실패, 데이터 동기화, 로드밸런싱, 개발 및 관리의 복잡성 문제가 있을 수 있다.
 - 수평-수직 복합 확장성 (Elastic Scalability):
    - 수평-수직 복합 확장성은 수직적 확장과 수평적 확장을 조합한 접근 방식입니다. 필요에 따라 서버의 하드웨어 리소스를 업그레이드하거나, 필요할 때마다 서버를 추가하여 확장합니다.

<br/>

## Redis Cluster 소개

Redis Cluster는 여러 대의 Redis 서버 노드를 활용하여 데이터의 분산 저장과 고가용성을 제공하는 Redis의 클러스터링 기능입니다. 이를 통해 Redis 데이터베이스의 확장성을 향상시키고, 높은 가용성을 유지할 수 있습니다. Redis Cluster는 주로 데이터의 분산과 확장을 목표로 하는 시나리오에서 사용됩니다.  
 - 여러 노드에 자동적인 데이터 분산
 - 일부 노드의 실패나 통신 단절에도 계속 작동하는 가용성
 - 고성능을 보장하면서 선형 확장성을 제공

<br/>

### Redis Cluster 특징

 - Full-mesh 구조로 통신
    - Redis Cluster에서는 모든 노드가 Full-mesh 구조로 통신합니다. 즉, 모든 노드가 서로 직접 연결되어 데이터의 분산 및 통신을 수행합니다.
    - Full-mesh 구조는 데이터 전송에 있어 효율적이지만 노드 수가 증가하면 통신 연결의 복잡성이 증가할 수 있습니다.
 - Cluster Bus라는 추가 채널(port) 사용
    - Redis Cluster는 Cluster Bus라는 추가적인 채널(port)을 사용하여 노드 간의 정보 교환을 수행합니다. 이를 통해 노드 간의 상태 정보 및 클러스터 구성 정보를 교환합니다.
 - Gossip Protocol 사용
    - Redis Cluster에서는 Gossip Protocol을 사용하여 노드 간의 정보를 교환하고 업데이트합니다. 노드가 주기적으로 다른 노드들에게 정보를 전파하면서 클러스터의 상태 정보를 유지합니다.
 - Hash Slot을 사용한 키 관리
    - Redis Cluster는 데이터를 해시 슬롯에 할당하여 분산 저장합니다. 각 노드는 특정 범위의 해시 슬롯를 관리하며, 키는 해당 슬롯에 할당됩니다.
 - DB0만 사용 가능
    - Redis Cluster에서는 모든 노드에서 DB0만 사용할 수 있습니다. 다른 데이터베이스(DB1, DB2 등)를 사용할 수 없으며, 모든 데이터는 DB0에 저장됩니다.
 - Multi Key 명령어가 제한됨
    - Redis Cluster에서는 명령어 중에서 여러 키를 대상으로 하는 Multi Key 명령어가 일부 제한됩니다. 왜냐하면 해당 명령어가 여러 해시 슬롯에 걸쳐 분산되는 작업을 처리하기 어려워서입니다.
 - 클라이언트는 모든 노드에 접속
    - Redis Cluster의 클라이언트는 모든 노드에 접속할 수 있습니다. 클라이언트는 노드 중 하나에 접속하고 해당 노드를 통해 클러스터의 모든 데이터에 액세스합니다.

<br/>

### Redis Cluster와 Sentinel과의 차이점

 - 클러스터는 데이터 분산(샤딩)을 제공함
 - 클러스터는 자동 장애 조치를 위한 모니터링 노드(Sentinel)를 추가 배치할 필요가 없음
 - 클러스터에서는 Multi Key 오퍼레이션이 제한됨
 - Sentinel은 비교적 단순하고 소규모의 시스템에서 HA(고가용성)가 필요할 때 채택

<br/>

## 데이터 분산과 Key 관리

### 데이터를 분산하는 기준

특정 Key의 데이터가 어느 노드(Shard)에 속할 것인지 결정하는 메커니즘이 있어야 하는데 보통 분산 시스템에서 해싱이 사용된다.  
하지만, 단순 해싱으로는 노드의 개수가 변할 떄 모든 매핑이 새로 계산되어야 하는 문제가 발생하게 된다.  

<br/>

### 해시 슬롯

Redis Cluster에서 데이터 분산을 관리하기 위해 해시 슬롯(Hash Slot)을 사용합니다. 해시 슬롯은 데이터베이스의 키를 분산하여 여러 개의 노드에 데이터를 저장하고 관리하는 기술입니다.  
Redis는 16384개의 Hash Slot으로 Key 공간을 나누어 관리하며, 각 키는 CRC16 해싱 후 16384로 modulo 연산을 하여 각 Hash Slot에 매핑된다. Hash Slot은 각 노드들에게 나누어 분배된다.  
 - 해시 슬롯의 개념:
    - Redis Cluster는 전체 데이터를 16384개의 해시 슬롯으로 분할합니다. 이 해시 슬롯은 0부터 16383까지의 숫자로 표현되며, 모든 키는 이러한 해시 슬롯 중 하나에 할당됩니다.
    - 각 노드는 일정 범위의 해시 슬롯를 관리하며, 클러스터의 모든 해시 슬롯가 모든 노드에 균등하게 분배되도록 설계됩니다.
 - 키 할당과 이동:
    - 클라이언트가 데이터를 저장할 때, 해당 데이터의 키는 해시 함수에 의해 해시 슬롯으로 매핑됩니다. 그런 다음, Redis Cluster는 이 해시 슬롯을 관리하는 노드에 데이터를 저장합니다.
    - 만약 노드 간의 데이터 분산이 불균형하게 되거나, 노드가 추가되거나 제거되면 Redis Cluster는 데이터의 재분배를 수행하여 균형을 유지합니다. 이를 데이터의 이동 또는 리슬로팅(Redis ReSharding)이라고 합니다.
 - 노드 간의 데이터 복제:
    - 마스터 노드에 저장된 데이터는 해당 마스터의 슬레이브 노드들에게 복제됩니다. 각 마스터 노드와 그에 해당하는 슬레이브 노드는 동일한 해시 슬롯을 관리하며, 데이터의 복제를 통해 고가용성과 안정성을 제공합니다.
 - 클라이언트의 데이터 접근
    - 클러스터 노드는 요청이 온 Key에 해당하는 노드로 자동 Redirect를 해주지 않음
    - 클라이언트는 MOVED 에러를 받으면 해당 노드로 다시 요청해야 함

<br/>

## 성능과 가용성

 - 클러스터를 사용할 때의 성능
    - 클라이언트가 MOVED 에러에 대해 재요청을 해야 하는 문제
        - 클라이언트(라이브러리)는 Key-Node 맵을 캐싱하므로 대부분의 경우 발생하지 않음
    - 클라이언트는 단일 인스턴스의 Redis를 이용할 때와 같은 성능으로 이용 가능
    - 분산 시스템에서 성능은 데이터 일관성과 Trade-Off가 있음
        - Redis Cluster는 고성능의 확장성을 제공하면서 적절한 수준의 데이터 안전성과 가용성을 유지하는 것을 목표로 설계됨
 - 클러스터의 데이터 일관성
    - Redis Cluster는 높은 성능을 위해 비동기 복제를 하기 때문에 Strong Consistency를 제공하지 않음
    - Client에서 Master로 Write 요청 > 비동기로 Replica 복제 수행, Client에 Ack 응답
    - Ack와 복제는 순서가 정해져 있지 않으므로 복제가 완료되기 전에 Master가 죽으면 데이터는 유실된다.
 - 클러스터의 가용성 (Auto Failover)
    - 일부 노드(Master)가 실패(또는 네트워크 단절) 하더라도 과반수 이상의 Master가 남아있고, 사라진 Master의 Replica들이 있다면 클러스터는 Failover되어 가용한 상태가 된다.
    - Node Timeout 동안 과반수의 Master와 통신하지 못한 Master는 스스로 Error State로 빠지고 Write 요청을 받지 않음
    - ex) Master1과 Replica2가 죽더라도, 2/3의 Master가 남아있고, Master1이 커버하던 Hash Slot은 Replica1이 Master로 승격되어 커버할 수 있다.

<br/>

## 클러스터의 제약 사항

 - DB0만 사용 가능하다.
    - Redis는 한 인스턴스에 여러 데이터베이스를 가질 수 있다.
    - Multi DB는 용도별로 분리해서 관리를 용이하게 하기 위한 목적
    - 클러스터에서는 해당 기능을 사용할 수 없고 DB0으로 고정된다.
 - Multi Key Operation 사용 제약
    - Key들이 각각 다른 노드에 저장되므로 MSET과 같은 Multi-Key Operation은 기본적으로 사용할 수 없다.
    - 같은 노드 안에 속한 Key들에 대해서는 Multi-Key Operation이 가능
    - Hash Tags 기능을 사용하면 여러 Key들을 같은 Hash Slot에 속하게 할 수 있음
        - Key 값 중 {} 안에 들어간 문자열에 대해서만 해싱을 수행하는 원리
        - ex) MSET {user:a}:age 20 {user:a}:city seoul
 - 클라이언트 구현의 강제
    - 클라이언트는 클러스터의 모든 노드에 접속해야 함
    - 클라이언트는 Redirect 기능을 구현해야 함 (MOVED 에러 대응)
    - 클라이언트 구현이 잘 된 라이브러리가 없는 환경도 있을 수 있음
