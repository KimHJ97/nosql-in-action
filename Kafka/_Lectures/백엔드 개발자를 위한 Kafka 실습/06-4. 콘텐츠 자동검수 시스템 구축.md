# 콘텐츠 자동검수 시스템 구축

 - Chat GPT API 사용 신청
 - envFile을 통해 API Key 환경 변수화
 - Chat GPT API 연동 Client 구현
 - Chat GPT Client를 사용하는 콘텐츠 검수 Port 구현
 - 콘텐츠 검수 Use Case 구현
 - 검수 결과(post.inspected) 토픽, 메시지 모델 생성
 - post.original 토픽에 대한 Consumer(자동 검수 Worker) 구현
 - post.inspected 토픽에 대한 Produce(검수 결과 콘텐츠에 대한 C,U,D 변경사항)
```
Root Project
 ├─ api
 ├─ domain
 ├─ adapter
 │   ├─ metadata-client
 │   ├─ mysql
 │   ├─ kafka
 │   └─ chat-gpt-client
 ├─ usecase
 │   ├─ core
 │   ├─ post-resolving-help-usecase
 │   └─ post-usecase
 └─ worker
     └─ auto-inspection-worker
```

 - `local.env`
    - ROOT 프로젝트에 local.env 파일 생성
    - IntelliJ EnvFile 플러그인 설치
    - 프로젝트 실행시 EnvFile 옵션 허용 후 local.env 파일 경로 지정
```
OPENAI_API_KEY=값
```

## 1. 콘텐츠 검수 도메인 모델 정의 (usecase/domain)

 - `InspectedPost`
```java
@RequiredArgsConstructor
@Getter
public class InspectedPost {

    private final Post post;
    private final String categoryName;
    private final List<String> autoGeneratedTags;
    private final LocalDateTime inspectedAt;

    public static InspectedPost generate(
        Post post,
        String categoryName,
        List<String> autoGeneratedTags
    ) {
        return new InspectedPost(
            post,
            categoryName,
            autoGeneratedTags,
            LocalDateTime.now()
        );
    }
}
```

 - `AutoInspectionResult`
    - 검수 결과
```java
@Data
@NoArgsConstructor
public class AutoInspectionResult {
    private String status; // "GOOD" or "BAD"
    private String[] tags;
}
```

## 2. 콘텐츠 검수 Use Case 정의 (usecase/inspected-post-usecase)

 - `build.gradle`
```groovy
dependencies {
    implementation(project(":usecase:core"))
}
```

 - `PostInspectUsecase`
```java
public interface PostInspectUsecase {
    InspectedPost inspectAndGetIfValid(Post post);
}
```

 - `PostInspectService`
```java
@RequiredArgsConstructor
@Service
public class PostInspectService implements PostInspectUsecase {

    private final MetadataPort metadataPort;
    private final PostAutoInspectPort postAutoInspectPort;

    @Override
    public InspectedPost inspectAndGetIfValid(Post post) {
        String categoryName = metadataPort.getCategoryNameByCategoryId(post.getCategoryId());
        AutoInspectionResult inspectionResult = postAutoInspectPort.inspect(post, categoryName);
        if (!inspectionResult.getStatus().equals("GOOD")) return null;
        return InspectedPost.generate(
            post,
            categoryName,
            Arrays.asList(inspectionResult.getTags())
        );
    }
}
```

## 3. Chat GPT 클라이언트 어뎁터 구현 (adapter/chat-gpt-client)

 - `build.gradle`
```groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux:3.2.0'
}
```

 - `config/ChatGptWebClientConfig`
```java
@Configuration
public class ChatGptWebClientConfig {

    @Bean
    @Qualifier("chatGptWebClient")
    public WebClient chatGptWebClient() {
        return WebClient.builder()
            .baseUrl("https://api.openai.com")
            .build();
    }
}
```

 - `model/ChatCompletionResponse`
```java
@Data
public class ChatCompletionResponse {
    private String id;
    private String object;
    private long created;
    private String model;
    private ChatChoice[] choices;
    private Usage usage;
    @JsonProperty("system_fingerprint")
    private String systemFingerprint;

    @Data
    @Getter
    public static class ChatChoice {
        private int index;
        private Message message;
        private Object logprobs;
        @JsonProperty("finish_reason")
        private String finishReason;

        @Data
        public static class Message {
            private String role;
            private String content;
        }
    }

    @Data
    public static class Usage {
        @JsonProperty("prompt_tokens")
        private int promptTokens;
        @JsonProperty("completion_tokens")
        private int completionTokens;
        @JsonProperty("total_tokens")
        private int totalTokens;
    }
}
```

 - `ChatGptClient`
```java
@Component
public class ChatGptClient {

    private static final String TARGET_GPT_MODEL = "gpt-3.5-turbo";

    public ChatGptClient(
        @Qualifier("chatGptWebClient") WebClient chatGptWebClient
    ) {
        this.chatGptWebClient = chatGptWebClient;
    }

    private final WebClient chatGptWebClient;

    @Value("${OPENAI_API_KEY}")
    private String openaiApiKey;

    private final CustomObjectMapper objectMapper = new CustomObjectMapper();

    public String getResultForContentWithPolicy(
        String content,
        ChatPolicy chatPolicy
    ) {
        String jsonString = chatGptWebClient
            .post()
            .uri("/v1/chat/completions")
            .header("Authorization", "Bearer " + openaiApiKey) // OpenAI API 키 추가
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(Map.of(
                "model", TARGET_GPT_MODEL,
                "messages", List.of(
                    Map.of("role", "system", "content", chatPolicy.instruction),
                    Map.of("role", "user", "content", chatPolicy.exampleContent),
                    Map.of("role", "assistant", "content", chatPolicy.exampleInspectionResult),
                    Map.of("role", "user", "content", content)
                ),
                "stream", false
            ))
            .retrieve()
            .bodyToMono(String.class)
            .block();
        try {
            ChatCompletionResponse response = objectMapper.readValue(jsonString, ChatCompletionResponse.class);
            return response.getChoices()[0].getMessage().getContent();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @Data
    public static class ChatPolicy {
        private final String instruction;
        private final String exampleContent;
        private final String exampleInspectionResult;
    }
}
```

 - `PostAutoInspectAdapter`
```java
@Component
@RequiredArgsConstructor
public class PostAutoInspectAdapter implements PostAutoInspectPort {

    private final ChatGptClient chatGptClient;

    private final CustomObjectMapper objectMapper = new CustomObjectMapper();

    @Override
    public AutoInspectionResult inspect(Post post, String categoryName) {
        // ChatGPT 질의(프롬프트) 내용 정의
        String contentString = buildContentString(post, categoryName);

        // ChatGPT 답변 정책 정의
        ChatGptClient.ChatPolicy chatPolicy = new ChatGptClient.ChatPolicy(
            AutoInspectionPolicy.INSPECTION_INSTRUCTION,
            AutoInspectionPolicy.EXAMPLE_CONTENT,
            AutoInspectionPolicy.EXAMPLE_INSPECTION_RESULT
        );

        try {
            // ChatGPT로 요청 후 검수 결과 반환
            String resultString = chatGptClient.getResultForContentWithPolicy(
                contentString,
                chatPolicy
            );
            return objectMapper.readValue(resultString, AutoInspectionResult.class);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private String buildContentString(Post post, String categoryName) {
        return String.format(
            "[%s] %s - %s",
            categoryName,
            post.getTitle(),
            post.getContent()
        );
    }

    static class AutoInspectionPolicy {
        private static final String INSPECTION_INSTRUCTION =
            "The task you need to accomplish is to return two items ('status' and 'tags') in JSON format. " +
                "The information I will provide will be in the format '[Post category] Post content.' " +
                "Then, if the content of the post aligns well with the meaning or theme of the post category, " +
                "fill the 'status' field with the string 'GOOD.' " +
                "If the meaning or theme appears unrelated, " +
                "fill the 'status' field with the string 'BAD.' " +
                "Additionally, extract and compile a list of up to 5 keywords " +
                "that seem most important in the post content and populate the 'tags' field with them.";
        private static final String EXAMPLE_CONTENT =
            "[Health] Reps and Muscle Size - To increase muscle size, " +
                "it is considered most ideal to exercise with the maximum weight " +
                "that allows 8 to 12 repetitions per set.";
        private static final String EXAMPLE_INSPECTION_RESULT =
            "{\"status\":\"GOOD\",\"tags\":[\"muscle\", \"weight\", \"repetitions\"]}";
    }
}
```

## 4. API

 - `InternalController`
    - postInspectUsecase 요청 테스트
```java
@RequiredArgsConstructor
@RestController
@RequestMapping("/internal")
public class InternalController {

    private final PostInspectUsecase postInspectUsecase;

    @GetMapping
    InspectedPost inspectionTest(
        @RequestParam("title") String title,
        @RequestParam("content") String content,
        @RequestParam("categoryId") Long categoryId
    ) {
        return postInspectUsecase.inspectAndGetIfValid(Post.generate(
            0L, // userId는 검수 결과에 영향을 미치지 않으므로 아무거나 입력
            title,
            content,
            categoryId
        ));
    }
}
```

## 5. 검수된 컨텐츠 발행 유즈케이스 (usecase/core)

 - `InspectedPostMessageProducePort`
```java
public interface InspectedPostMessageProducePort {
    void sendCreateMessage(InspectedPost inspectedPost);
    void sendUpdateMessage(InspectedPost inspectedPost);
    void sendDeleteMessage(Long id);
}
```

## 6. Kafka 구현체 (adapter/kafka)

 - `InspectedPostMessage`
```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class InspectedPostMessage {
    private Long id;
    private Payload payload;
    private OperationType operationType;

    @AllArgsConstructor
    @NoArgsConstructor
    @Data
    public static class Payload {
        private Post post;
        private String categoryName;
        private List<String> autoGeneratedTags;
        private LocalDateTime inspectedAt;
    }
}
```

 - `InspectedPostMessageProduceAdapter`
```java
@RequiredArgsConstructor
@Component
public class InspectedPostMessageProduceAdapter implements InspectedPostMessageProducePort {

    private final KafkaTemplate<String, String> kafkaTemplate;
    private final CustomObjectMapper objectMapper = new CustomObjectMapper();

    @Override
    public void sendCreateMessage(InspectedPost inspectedPost) {
        InspectedPostMessage message = new InspectedPostMessage(
            inspectedPost.getPost().getId(),
            new InspectedPostMessage.Payload(
                inspectedPost.getPost(),
                inspectedPost.getCategoryName(),
                inspectedPost.getAutoGeneratedTags(),
                inspectedPost.getInspectedAt()
            ),
            OperationType.CREATE
        );
        this.sendMessage(message);
    }

    @Override
    public void sendUpdateMessage(InspectedPost inspectedPost) {
        InspectedPostMessage message = new InspectedPostMessage(
            inspectedPost.getPost().getId(),
            new InspectedPostMessage.Payload(
                inspectedPost.getPost(),
                inspectedPost.getCategoryName(),
                inspectedPost.getAutoGeneratedTags(),
                inspectedPost.getInspectedAt()
            ),
            OperationType.UPDATE
        );
        this.sendMessage(message);
    }

    @Override
    public void sendDeleteMessage(Long postId) {
        InspectedPostMessage message = new InspectedPostMessage(
            postId,
            null,
            OperationType.DELETE
        );
        this.sendMessage(message);
    }

    private void sendMessage(InspectedPostMessage message) {
        try {
            kafkaTemplate.send(INSPECTED_POST, message.getId().toString(), objectMapper.writeValueAsString(message));
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }
}
```

 - `KafkaConfig`
    - 컨슈머 관련 설정 추가
```java
@Configuration
@EnableKafka
public class KafkaConfig {

    // ..

    @Bean
    @Primary
    public ConsumerFactory<String, Object> consumerFactory(KafkaProperties kafkaProperties) {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaProperties.getBootstrapServers());
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.ALLOW_AUTO_CREATE_TOPICS_CONFIG, "false");
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, "false");
        return new DefaultKafkaConsumerFactory<>(props);
    }

    @Bean
    @Primary
    CommonErrorHandler errorHandler() {
        CommonContainerStoppingErrorHandler cseh = new CommonContainerStoppingErrorHandler();
        AtomicReference<Consumer<? ,?>> consumer2 = new AtomicReference<>();
        AtomicReference<MessageListenerContainer> container2 = new AtomicReference<>();

        DefaultErrorHandler errorHandler = new DefaultErrorHandler((rec, ex) -> {
            cseh.handleRemaining(ex, Collections.singletonList(rec), consumer2.get(), container2.get());
        }, generateBackOff()) {

            @Override
            public void handleRemaining(
                Exception thrownException,
                List<ConsumerRecord<?, ?>> records,
                Consumer<?, ?> consumer,
                MessageListenerContainer container
            ) {
                consumer2.set(consumer);
                container2.set(container);
                super.handleRemaining(thrownException, records, consumer, container);
            }
        };
        errorHandler.addNotRetryableExceptions(JsonProcessingException.class);
        return errorHandler;
    }

    @Bean
    @Primary
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory(
        ConsumerFactory<String, Object> consumerFactory,
        CommonErrorHandler errorHandler
    ) {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory);
        factory.setCommonErrorHandler(errorHandler);
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.RECORD);
        return factory;
    }

    private BackOff generateBackOff() {
        ExponentialBackOff backOff = new ExponentialBackOff(1000, 2);
        backOff.setMaxAttempts(3);
        return backOff;
    }
}
```

## 7. 원본 콘텐츠 메시지 발행시 콘텐츠 검수를 처리하는 워커(worker/auto-inspection-worker)

 - `build.gradle`
```groovy
dependencies {
    implementation(project(":common"))
    implementation(project(":domain"))

    implementation(project(":usecase:core"))
    implementation(project(":usecase:inspected-post-usecase"))

    implementation(project(":adapter:kafka"))
    implementation(project(":adapter:metadata-client"))
    implementation(project(":adapter:chat-gpt-client"))
}
```

 - `application.yml`
```yml
server:
  port: 8082

spring:
  kafka:
    bootstrap-servers: localhost:9092,localhost:9093,localhost:9094

external-server:
  metadata:
    url: http://localhost:8088
```

 - `AutoInspectionWorker`
    - "post.original" 토픽을 컨슘한다.
    - 콘텐츠 내용을 ChatGPT API로 검수하고, "post.inspected" 토픽에 메시지 발행
```java
@RequiredArgsConstructor
@Component
public class AutoInspectionWorker {

    private final CustomObjectMapper objectMapper = new CustomObjectMapper();

    private final PostInspectUsecase postInspectUsecase;
    private final InspectedPostMessageProducePort inspectedPostMessageProducePort;

    @KafkaListener(
        topics = { Topic.ORIGINAL_POST },
        groupId = "auto-inspection-consumer-group",
        concurrency = "3"
    )
    public void listen(ConsumerRecord<String, String> message) throws JsonProcessingException {
        OriginalPostMessage originalPostMessage = objectMapper.readValue(message.value(), OriginalPostMessage.class);

        if (originalPostMessage.getOperationType() == OperationType.CREATE) {
            this.handleCreate(originalPostMessage);
        } else if (originalPostMessage.getOperationType() == OperationType.UPDATE) {
            this.handleUpdate(originalPostMessage);
        } else if (originalPostMessage.getOperationType() == OperationType.DELETE) {
            this.handleDelete(originalPostMessage);
        }
    }

    private void handleCreate(OriginalPostMessage originalPostMessage) {
        InspectedPost inspectedPost = postInspectUsecase.inspectAndGetIfValid(
            OriginalPostMessageConverter.toModel(originalPostMessage)
        );
        if (inspectedPost == null) {
            return;
        }
        inspectedPostMessageProducePort.sendCreateMessage(inspectedPost);
    }

    private void handleUpdate(OriginalPostMessage originalPostMessage) {
        InspectedPost inspectedPost = postInspectUsecase.inspectAndGetIfValid(
            OriginalPostMessageConverter.toModel(originalPostMessage)
        );
        if (inspectedPost == null) {
            inspectedPostMessageProducePort.sendDeleteMessage(originalPostMessage.getId());
        } else {
            inspectedPostMessageProducePort.sendUpdateMessage(inspectedPost);
        }
    }

    private void handleDelete(OriginalPostMessage originalPostMessage) {
        // DELETE 메시지는 검수가 필요 없으므로 바로 삭제
        inspectedPostMessageProducePort.sendDeleteMessage(originalPostMessage.getId());
    }
}
```
